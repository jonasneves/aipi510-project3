name: Live Server

# Fixed run name - won't change based on commit message
run-name: "Live Server - aisalary.neevs.io"

on:
  # Auto-restart on push to main
  push:
    branches: [refine-data-collection] # TODO: change back to main
    paths:
      - 'api/**'
      - 'frontend-react/**'
      - 'src/**'
      - 'requirements.txt'
  # Manual trigger
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'How long to run (max 5.5 hours)'
        required: false
        default: '5.5'
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: 'true'
        type: boolean
      instances:
        description: 'Number of parallel instances (1-2 for redundancy)'
        required: false
        default: '1'
        type: choice
        options:
          - '1'
          - '2'
  # Programmatic restart (for timeout rotation)
  repository_dispatch:
    types: [restart-tunnel]

env:
  AWS_REGION: us-east-1
  S3_BUCKET: ai-salary-predictor

jobs:
  host:
    name: Live Server #${{ matrix.instance }}
    runs-on: ubuntu-24.04-arm
    timeout-minutes: 350
    strategy:
      matrix:
        instance: ${{ fromJson((github.event.client_payload.instances || github.event.inputs.instances || '1') == '2' && '[1,2]' || '[1]') }}
      fail-fast: false

    permissions:
      id-token: write
      contents: read
      actions: write

    steps:
      - name: Find previous running workflow
        id: find_previous
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Current run ID: ${{ github.run_id }}"

          # Find other running instances of this workflow (excluding current run)
          API_RESPONSE=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/tunnel-hosting.yml/runs?status=in_progress")

          RUN_COUNT=$(echo "$API_RESPONSE" | jq '.total_count')
          echo "Total in_progress runs found: $RUN_COUNT"

          # Only consider strictly older runs to avoid cross-cancelling newer runs
          PREVIOUS_RUN_ID=$(echo "$API_RESPONSE" | jq -r ".workflow_runs[] | select(.id < ${{ github.run_id }}) | .id" | head -1)

          if [ -n "$PREVIOUS_RUN_ID" ] && [ "$PREVIOUS_RUN_ID" != "null" ] && [ "$PREVIOUS_RUN_ID" != "" ]; then
            echo "Found previous running workflow: $PREVIOUS_RUN_ID"
            echo "previous_run_id=$PREVIOUS_RUN_ID" >> $GITHUB_OUTPUT
          else
            echo "No previous running workflow found"
            echo "previous_run_id=" >> $GITHUB_OUTPUT
          fi

      - uses: actions/checkout@v4

      - name: Set up uv
        uses: astral-sh/setup-uv@v3
        with:
          enable-cache: true
          cache-dependency-glob: "requirements-runtime.txt"

      - name: Create venv (Python 3.11)
        run: |
          uv venv --python 3.11 --seed
          echo "VIRTUAL_ENV=$PWD/.venv" >> $GITHUB_ENV
          echo "$PWD/.venv/bin" >> $GITHUB_PATH

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Cache node_modules
      - name: Cache node modules
        uses: actions/cache@v4
        id: npm-cache
        with:
          path: frontend-react/node_modules
          key: npm-${{ hashFiles('frontend-react/package.json') }}

      # Cache frontend build
      - name: Cache frontend build
        uses: actions/cache@v4
        id: build-cache
        with:
          path: frontend-react/dist
          key: frontend-build-${{ hashFiles('frontend-react/**/*.ts', 'frontend-react/**/*.tsx', 'frontend-react/**/*.css', 'frontend-react/package.json') }}

      # Cache cloudflared binary
      - name: Cache cloudflared
        uses: actions/cache@v4
        id: cloudflared-cache
        with:
          path: /usr/local/bin/cloudflared
          key: cloudflared-linux-arm64-v1

      # Cache spaCy model
      - name: Cache spaCy model
        uses: actions/cache@v4
        id: spacy-cache
        with:
          path: |
            ~/.cache/spacy
            ~/spacy_data
          key: spacy-en_core_web_sm-v3-${{ runner.arch }}

      - name: Install Python dependencies
        run: |
          # Use minimal runtime requirements for faster install
          uv pip install -r requirements-runtime.txt
          # Pre-compile Python bytecode for faster imports
          python -m compileall -q src/ api/ || true

      - name: Download spaCy model
        if: steps.spacy-cache.outputs.cache-hit != 'true'
        run: |
          echo "Downloading spaCy model for resume parsing..."
          python -m spacy download en_core_web_sm

      - name: Install node modules
        if: steps.npm-cache.outputs.cache-hit != 'true'
        run: |
          npm install -g serve
          cd frontend-react && npm install

      - name: Build frontend
        if: steps.build-cache.outputs.cache-hit != 'true'
        run: |
          cd frontend-react
          npm run build

      # Configure AWS to check model timestamp
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # Get model timestamp for cache invalidation
      - name: Get model timestamp
        id: model-timestamp
        run: |
          TIMESTAMP=$(aws s3api head-object \
            --bucket ${{ env.S3_BUCKET }} \
            --key models/latest/salary_model_latest.pkl \
            --query 'LastModified' --output text 2>/dev/null || echo "unknown")
          # Convert to date-only for cache key stability
          DATE=$(echo "$TIMESTAMP" | cut -d'T' -f1 || echo "unknown")
          echo "timestamp=$DATE" >> $GITHUB_OUTPUT
          echo "Model last modified: $TIMESTAMP (using $DATE for cache key)"

      # Cache model with timestamp-based key
      - name: Cache model
        uses: actions/cache@v4
        id: model-cache
        with:
          path: models
          key: model-${{ steps.model-timestamp.outputs.timestamp }}
          restore-keys: |
            model-

      - name: Download model from S3
        if: steps.model-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p models
          aws s3 cp s3://${{ env.S3_BUCKET }}/models/latest/ models/ --recursive

      - name: Verify model
        run: |
          if [ ! -f models/salary_model_latest.pkl ]; then
            echo "ERROR: Model not found"
            exit 1
          fi
          echo "Model files:"
          ls -la models/

      - name: Install cloudflared
        if: steps.cloudflared-cache.outputs.cache-hit != 'true'
        run: |
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            URL="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64"
          elif [ "$ARCH" = "aarch64" ]; then
            URL="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-arm64"
          else
            echo "Unsupported architecture: $ARCH"
            exit 1
          fi
          
          echo "Downloading cloudflared for $ARCH..."
          curl -L "$URL" -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Run services with tunnel
        continue-on-error: true
        run: |
          set -e

          # Handle cancellation gracefully
          cleanup() {
            echo ""
            echo "=== Shutting down ==="
            pkill -f cloudflared || true
            pkill -f uvicorn || true
            pkill -f "serve.*8501" || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT

          # Start API on port 8000 (Cloudflare routes /api here)
          echo "=== Starting API ==="
          uvicorn api.main:app --host 127.0.0.1 --port 8000 2>&1 | tee /tmp/api.log &
          API_PID=$!
          echo "API PID: $API_PID"

          # Wait for API to be ready
          for i in {1..30}; do
            if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
              echo "API is ready"
              break
            fi
            echo "Waiting for API... ($i/30)"
            sleep 2
          done

          # Check API health
          curl -s http://localhost:8000/health || { echo "API failed to start"; cat /tmp/api.log; exit 1; }

          # Start static file server on port 8501 (Cloudflare routes /* here)
          echo ""
          echo "=== Starting Frontend ==="
          # Enable CORS for better performance
          serve -s frontend-react/dist -l 8501 --cors &
          SERVE_PID=$!
          echo "Frontend PID: $SERVE_PID"
          sleep 5
          curl -sf http://localhost:8501 && echo "Frontend is ready" || echo "Warning: Frontend health check failed"

          # Start Cloudflare Tunnel with logging
          echo ""
          echo "=== Starting Cloudflare Tunnel ==="
          cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }} 2>&1 | tee /tmp/tunnel.log &
          TUNNEL_PID=$!
          echo "Tunnel PID: $TUNNEL_PID"
          sleep 10

          # Show tunnel status
          echo ""
          echo "=== Tunnel Log (first 50 lines) ==="
          head -50 /tmp/tunnel.log || true

          # Graceful handoff: Cancel previous workflow now that new instance is healthy
          PREVIOUS_RUN_ID="${{ steps.find_previous.outputs.previous_run_id }}"
          if [ -n "$PREVIOUS_RUN_ID" ]; then
            echo ""
            echo "=========================================="
            echo "New server is ready, cancelling previous workflow run: $PREVIOUS_RUN_ID"
            echo "=========================================="

            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/actions/runs/$PREVIOUS_RUN_ID/cancel")

            HTTP_CODE=$(echo "$RESPONSE" | tail -1)

            if [ "$HTTP_CODE" = "202" ]; then
              echo ""
              echo "✓ Previous workflow cancellation accepted"
              echo "Waiting 3 minutes for graceful handoff..."
              for i in {1..18}; do
                printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
                sleep 10
              done
              echo ""
              echo "Handoff complete. This instance is now primary."
            else
              echo "⚠ Cancel request returned code $HTTP_CODE"
              sleep 5
            fi
          fi

          # Calculate duration
          HOURS="${{ github.event.client_payload.duration_hours || github.event.inputs.duration_hours || '5.5' }}"
          DURATION=$(echo "$HOURS * 3600" | bc | cut -d. -f1)
          # Trigger restart 6 minutes before timeout (3 min handoff wait + 3 min buffer)
          RESTART_THRESHOLD=$((DURATION - 360))
          START_TIME=$(date +%s)
          RESTART_TRIGGERED=false

          # Auto-restart defaults to true unless explicitly set to false
          AUTO_RESTART="${{ github.event.client_payload.auto_restart || github.event.inputs.auto_restart }}"
          if [ -z "$AUTO_RESTART" ]; then
            AUTO_RESTART="true"
          fi

          # Store instances count for restart trigger
          INSTANCES="${{ github.event.client_payload.instances || github.event.inputs.instances || '1' }}"

          echo ""
          echo "=========================================="
          echo "Services running for $HOURS hours"
          echo "App:      https://aisalary.neevs.io"
          echo "API:      https://aisalary.neevs.io/api"
          echo "=========================================="
          echo ""

          # Monitoring loop
          LOOP_COUNT=0
          while true; do
            ELAPSED=$(($(date +%s) - START_TIME))
            REMAINING=$((DURATION - ELAPSED))
            LOOP_COUNT=$((LOOP_COUNT + 1))

            # Health checks
            API_OK=$(curl -sf http://localhost:8000/health > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            FRONTEND_OK=$(curl -sf http://localhost:8501 > /dev/null 2>&1 && echo "OK" || echo "DOWN")
            TUNNEL_OK=$(pgrep -f cloudflared > /dev/null && echo "OK" || echo "DOWN")

            printf "[%s] API: %s | Frontend: %s | Tunnel: %s | Elapsed: %dm | Remaining: %dm\n" \
              "$(date '+%H:%M:%S')" "$API_OK" "$FRONTEND_OK" "$TUNNEL_OK" "$((ELAPSED/60))" "$((REMAINING/60))"

            # Show recent logs every 5 iterations
            if [ $((LOOP_COUNT % 5)) -eq 0 ]; then
              echo "--- Recent tunnel log ---"
              tail -5 /tmp/tunnel.log 2>/dev/null || true
              echo "-------------------------"
            fi

            # Restart API if down
            if [ "$API_OK" = "DOWN" ]; then
              echo "Restarting API..."
              pkill -f "uvicorn api.main:app" || true
              uvicorn api.main:app --host 127.0.0.1 --port 8000 2>&1 | tee -a /tmp/api.log &
              sleep 5
            fi

            # Restart Frontend if down
            if [ "$FRONTEND_OK" = "DOWN" ]; then
              echo "Restarting Frontend..."
              pkill -f "serve.*8501" || true
              serve -s frontend-react/dist -l 8501 --cors &
              sleep 3
            fi

            if [ "$TUNNEL_OK" = "DOWN" ]; then
              echo "Restarting Tunnel..."
              cloudflared tunnel --no-autoupdate run --token ${{ secrets.CLOUDFLARE_TUNNEL_TOKEN }} 2>&1 | tee -a /tmp/tunnel.log &
              sleep 5
            fi

            # Trigger restart before timeout (only from instance #1 to avoid multiple dispatches)
            if [ "$ELAPSED" -gt "$RESTART_THRESHOLD" ] && [ "$RESTART_TRIGGERED" = "false" ] && [ "${{ matrix.instance }}" = "1" ]; then
              if [ "$AUTO_RESTART" = "true" ]; then
                echo ""
                echo "=========================================="
                echo "Triggering restart workflow..."
                echo "=========================================="

                # Check if WORKFLOW_PAT is set
                PAT_TOKEN="${{ secrets.WORKFLOW_PAT }}"
                if [ -z "$PAT_TOKEN" ]; then
                  echo "ERROR: WORKFLOW_PAT secret is not set!"
                  echo ""
                  echo "To fix this:"
                  echo "1. Go to GitHub Settings > Developer settings > Personal access tokens"
                  echo "2. Create a new token (classic) with 'repo' scope"
                  echo "3. Go to your repository Settings > Secrets and variables > Actions"
                  echo "4. Add a new secret named WORKFLOW_PAT with the token value"
                  echo ""
                  echo "Runner will exit without auto-restart."
                  RESTART_TRIGGERED=true
                else
                  # IMPORTANT: GITHUB_TOKEN cannot trigger workflows (security limitation)
                  # Must use a Personal Access Token with 'repo' scope stored as WORKFLOW_PAT
                  echo "Sending repository_dispatch event..."
                  RESPONSE=$(curl -sX POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer $PAT_TOKEN" \
                    -H "X-GitHub-Api-Version: 2022-11-28" \
                    https://api.github.com/repos/${{ github.repository }}/dispatches \
                    -d "{\"event_type\":\"restart-tunnel\",\"client_payload\":{\"duration_hours\":\"$HOURS\",\"auto_restart\":$([ \"$AUTO_RESTART\" = \"true\" ] && echo \"true\" || echo \"false\"),\"instances\":\"$INSTANCES\"}}" \
                    -w "\nHTTP_STATUS:%{http_code}" 2>&1)

                  HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
                  BODY=$(echo "$RESPONSE" | grep -v "HTTP_STATUS:")

                  echo "HTTP Status: $HTTP_CODE"
                  if [ -n "$BODY" ]; then
                    echo "Response body: $BODY"
                  fi

                  if [ "$HTTP_CODE" = "204" ]; then
                    echo ""
                    echo "SUCCESS: Restart triggered!"
                    echo "New runner will start shortly..."
                    echo ""
                    echo "Waiting 3 minutes to allow new runner to initialize..."
                    echo "This ensures graceful handoff with minimal downtime."

                    # Wait for new runner to start building
                    # This gives ~3 min for new runner to: checkout, install deps, start services
                    for i in {1..18}; do
                      printf "  Handoff wait: %d/180 seconds...\r" "$((i * 10))"
                      sleep 10
                    done
                    echo ""
                    echo "Handoff wait complete. New runner should be ready."
                  elif [ "$HTTP_CODE" = "401" ]; then
                    echo ""
                    echo "ERROR: Authentication failed (401)"
                    echo "Your WORKFLOW_PAT token may be expired or invalid."
                    echo ""
                    echo "To fix: Generate a new Personal Access Token with 'repo' scope"
                  elif [ "$HTTP_CODE" = "403" ]; then
                    echo ""
                    echo "ERROR: Permission denied (403)"
                    echo "Your WORKFLOW_PAT lacks required permissions."
                    echo ""
                    echo "To fix:"
                    echo "- For Classic PAT: Enable 'repo' scope (full control)"
                    echo "- For Fine-grained PAT: Enable 'Contents: Read and write'"
                    echo ""
                    echo "Recommended: Use a Classic PAT with 'repo' scope"
                  elif [ "$HTTP_CODE" = "404" ]; then
                    echo ""
                    echo "ERROR: Repository not found (404)"
                    echo "Your WORKFLOW_PAT may not have access to this repository."
                    echo ""
                    echo "To fix: Ensure the PAT has 'repo' scope and access to this repository"
                  elif [ "$HTTP_CODE" = "422" ]; then
                    echo ""
                    echo "ERROR: Invalid request (422)"
                    echo "The event_type 'restart-tunnel' may not be configured correctly."
                  else
                    echo ""
                    echo "ERROR: Failed to trigger restart (HTTP $HTTP_CODE)"
                    echo ""
                    echo "To fix: Create a Personal Access Token with 'repo' scope"
                    echo "and add it as repository secret named WORKFLOW_PAT"
                  fi

                  RESTART_TRIGGERED=true
                fi
              fi
            fi

            # Exit if duration reached
            if [ "$ELAPSED" -gt "$DURATION" ]; then
              echo "Duration reached"
              break
            fi

            sleep 30
          done

          cleanup

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== API Log ==="
          cat /tmp/api.log 2>/dev/null || echo "No API log"
          echo ""
          echo "=== Tunnel Log ==="
          cat /tmp/tunnel.log 2>/dev/null || echo "No tunnel log"

  notify:
    needs: host
    runs-on: ubuntu-24.04-arm
    if: always()
    steps:
      - name: Session ended
        run: echo "Tunnel hosting ended - ${{ needs.host.result }}"
